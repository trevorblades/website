---
title: Let's Talk Regular Polygons
description: Spiralling into the world of geometry
styles:
  .spiral:
    width: 100%
    maxHeight: 300px
---

Earlier this year, I thought it would be cool to try building a spiralling triangle of text using HTML and CSS. I suppose it had no practical benefit, but like I said, I thought it would be cool. And it was.

I started by sketching in my notebook to wrap my head around the ways in which I could achieve this effect. I landed on a technique that I'll call the "curly caterpillar" method.

## The curly caterpillar

First, I lay out each of my triangle sides horizontally with each one nested within the side before it. Then I use a CSS `transform` to `rotate()` each of the sides around their left axis. Because the sides are nested, a rotation to one side will also rotate its already rotated children, causing this "curling" effect.

> Try it out below. As you apply rotation to the joints between the three segments below, they curl inward to form a triangle.

import {CaterpillarDemo, SpiralDemo} from '../../components/CaterpillarDemo';

<CaterpillarDemo />

In React, one of these segment components might look something like the following. Notice the segment width is applied to the inner `span` and the rotation is applied to the outer flex parent. Each subsequent segment is nested within the previous one, after the `span` using the `children` prop.

```jsx
function Segment({children, value, width, rotation}) {
  return (
    <div
      style={{
        display: 'flex',
        transformOrigin: 'left',
        transform: `rotate(${rotation}deg)`
      }}
    >
      <span
        style={{
          flexShrink: 0,
          width
        }}
      >
        {value}
      </span>
      {children}
    </div>
  );
}
```

To create a triangle, arrange the above `Segment` components like the following example, and rotate all but the first segment **120Â°**.

The triangle I'm trying to build is [equilateral](https://en.wikipedia.org/wiki/Equilateral_polygon), meaning each of its side lengths and angles are the same. Since the sum of all interior angles in any triangle must equal 180Â°, each _interior angle_ will be 60Â°. Knowing that each _exterior angle_ can be calculated as the sum of two interior angles, each exterior angle must be 120Â°. That's the amount that I need to rotate each segment to turn my flat line into a triangle.

> To learn more about basic laws of triangles, [check out this article](https://en.wikipedia.org/wiki/Triangle#Basic_facts) that explains things much better and with diagrams ðŸ”¥

```jsx
function Triangle() {
  const width = 100; // in pixels
  const interiorAngle = 180 / 3; // in degrees
  const exteriorAngle = interiorAngle * 2; // or 180 - interiorAngle
  return (
    // the outermost segment gets no rotation
    <Segment value="first" width={width} rotation={0}>
      <Segment value="second" width={width} rotation={exteriorAngle}>
        {/* the innermost segment gets no further children */}
        <Segment value="third" width={width} rotation={exteriorAngle} />
      </Segment>
    </Segment>
  );
}
```

## Math time

The story doesn't end here. I am trying to create a **spiral** triangle, after all. That means after drawing the first three sides, the shape needs to continue spiralling inward as long as there's room to create new segments.

The amount of room needed to draw a segment is related to the desired amount of space between parallel lines in the spiral. Let's use the following spiral with simplified measurements as an example. Its first two segments are 100 units long, and it has 20 units of spacing between its parallel lines.

import {Spiral1, Spiral2, Spiral3, Spiral4} from '../../components/Spirals';

<Spiral1 className="spiral" />

In order to continue drawing this spiral, I needed to figure out the length of its third side. At first glance, the answer might seem obvious: just subtract 20 from the original side length of 100, and we get a side length of 80.

Unfortunately, it's not that simple. This calculation results in a side that's slightly too long to ensure the subsequent sides are correctly spaced.

<Spiral2 className="spiral" />

To find the appropriate length for side 3 and greater, we need to first calculate the length of the piece that needs to be removed. In the diagram below, I've labelled that part as $a$.

If you look closely at side $a$, it's the hypoteneuse of an imaginary right triangle that has an opposite side length equal to the gap between parallel lines in the spiral (20). We also know that one of the angles is 60Â° because that's the same as each interior angle in the triangle.

<Spiral3 className="spiral" />

With this knowledge, we can apply basic trigonometry to solve for $a$. Remember [**SohCahToa**](https://en.wikipedia.org/wiki/Trigonometry#Mnemonics)? Since we have the length of the opposite side ($O$) and want to solve for the hypoteneuse ($H$), we must use the sine function in this calculation.

$$
\begin{aligned}
\sinÎ¸ = \frac{O}{H} \\
\sin60Â° = \frac{20}{a} \\
a = \frac{20}{\sin60Â°} \\
a \approx 23.09
\end{aligned}
$$

In my code, I refer to this side $a$ measurement as the _inset_. Now solving for $b$ is as easy as subtracting the inset $a$ from the original side length of 100.

$$
\begin{aligned}
b = 100 - a \\
b \approx 100 - 23.09 \\
b \approx 76.91
\end{aligned}
$$

This process of subtracting the inset from the original side length continues for each subsequent side until there's no more room to draw additional sides. In the diagram below, you can see that each inset, marked as $\vert$, is the same length.

Calculating the length of side $3$ is as simple as subtracting _one_ inset from the original side length, but side $4$ requires us to subtract one inset along with two additional lengths that I call _outsets_, marked as $\Vert$ in the diagram. Side $5$ is equal to the original side length minus two insets and two outsets, and so on.

<Spiral4 className="spiral" />

The length of an outset can be calculated using another staple of trigonometry, Pythagorean theorum. This equation, commonly expressed as $a^2 + b^2 = c^2$, lets us solve for one side of a right triangle, given that we know the length of the other two sides. In this case, the spacing between parallel lines is one side, and the inset is the triangle's hypoteneuse.

$$
\begin{aligned}
a^2 + b^2 = c^2 \\
a = \sqrt{c^2 - b^2} \\
a = \sqrt{23.09^2 - 20^2} \\
a \approx 11.54
\end{aligned}
$$

Knowing how to compute side lengths is great, but I need to apply this technique recursively until all sides are drawn. To do this, I needed to find a pattern or formula to follow for each side.

I drew a big spiral in my notebook and counted the insets and outsets for each side. I went about 10 sides deep to see if any pattern would emerge. Here's what my results looked like:

| Side | Insets | Outsets |
| ---- | ------ | ------- |
| 1    | 0      | 0       |
| 2    | 0      | 0       |
| 3    | 1      | 0       |
| 4    | 1      | 2       |
| 5    | 2      | 2       |
| 6    | 3      | 2       |
| 7    | 3      | 4       |
| 8    | 4      | 4       |
| 9    | 5      | 4       |
| 10   | 5      | 6       |

The outsets column presents a clear pattern. Every three sides, the number of outsets increments by two. In mathematical notation, we could express this formula where $O$ is the number of outsets, $n$ is the current side, and $S$ is the total number of sides on the shapeâ€”3 in the case of a triangle.

$$
O = 2\lfloor\frac{n - 1}{S}\rfloor
$$

> The $\lfloor{x}\rfloor$ syntax above means "floor" or "round this number down"

The pattern for the insets was a lot more unclear, but after some trial and error, I came up with the following handy formula, where $I$ is the number of insets, and the variables $n$ and $S$ are the same as above.

$$
I = \lfloor\frac{n}{S}\rfloor + \lfloor\frac{\max(n - 2, 0)}{S}\rfloor
$$

In JavaScript, these relationships would look something like this:

```js
const numInsets =
  Math.floor(side / numSides) + Math.floor(Math.max(side - 2, 0) / numSides);
const numOutsets = 2 * Math.floor((side - 1) / numSides);
```

There are three key values at play in both of these calculations:

- `Math.floor(side / numSides)`
- `Math.floor((side - 1) / numSides)`
- `Math.floor(Math.max(side - 2, 0) / numSides)`

Pretty similar, right? We can make this code more concise by creating these values iteratively and combining them appropriately.

```js
const [a, b, c] = Array.from({length: 3}, (_, index) =>
  Math.max(Math.floor((side - index) / numSides), 0)
);
const numInsets = a + c;
const numOutsets = 2 * b;
```

Talk about how to loop until all sides are created (no sides less than the spacing)

<SpiralDemo />

- The idea
- Creating a triangle by cascading CSS rotations
- Calculating the degree of each rotations

Once upon a time, I wanted to build a spiral...

- laying out text as a spiral
- first idea (caterpillar)
- text segments nested within eachother
- each segment's rotation rotates its children too, curling up like a pill bug
- how much should each segment rotate?
- how to maintain space between layers of the spiral?
- how to decide where to clip text? first approach: manually supply text segments
- problem with that: doesn't work reliably when the # of sides changes or the size of the spiral changes
- auto-splitting text might leave a bunch of empty space
- solution: just keep repeating the text if it ends early

another para

- talk about circle expanding to viewport
- pixel site does this: https://store.google.com/ca/product/pixel_5?hl=en-GB
- trig principles at play here
- sidenote about how to get katex working with gatsby + mdx
